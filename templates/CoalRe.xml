<beast version="2.0"
       namespace="beast.app.beauti
                 :beast.core
                 :beast.evolution.branchratemodel
                 :beast.evolution.speciation
                 :beast.evolution.tree.coalescent
                 :beast.core.util
                 :beast.evolution.nuc
                 :beast.evolution.operators
                 :beast.evolution.sitemodel
                 :beast.evolution.substitutionmodel
                 :beast.evolution.likelihood
                 :beast.evolution
                 :beast.math.distributions">

    <mergewith point="treePriorTemplates">

        <!-- Coalescent with Reassortment -->
        <subtemplate id="CoalescentWithReassortment" class="coalre.util.DummyTreeDistribution" mainid="CoalescentWithReassortmentDummy.t:$(n)">
            <![CDATA[
            <stateNode id="reassortmentRateCwR" spec="beast.core.parameter.RealParameter" value="0.1" estimate="true"/>
            <stateNode id="popSizeCwR" spec="beast.core.parameter.RealParameter" value="1.0" estimate="true"/>
            <stateNode id="networkCwR" spec="coalre.simulator.SimulatedCoalescentNetwork" nSegments="1"
                        enableSegmentTreeUpdate="false" estimate="true">
                <reassortmentRate idref="reassortmentRateCwR"/>
                <populationModel spec="beast.evolution.tree.coalescent.ConstantPopulation">
                    <popSize idref="popSizeCwR"/>
                </populationModel>

                <taxonSet spec="beast.evolution.alignment.TaxonSet" alignment="@$(n)"/>
            </stateNode>

            <plugin spec="coalre.util.DummyTreeDistribution" id="CoalescentWithReassortmentDummy.t:$(n)" tree="@Tree.t:$(n)"/>

            <plugin spec="coalre.distribution.CoalescentWithReassortment" id="CoalescentWithReassortmentPrior">
                <reassortmentRate idref="reassortmentRateCwR"/>
                <populationModel spec="beast.evolution.tree.coalescent.ConstantPopulation">
                    <popSize idref="reassortmentRateCwR"/>
                </populationModel>
                <networkIntervals id="networkIntervalsCwR" spec="coalre.distribution.NetworkIntervals">
                    <network idref="networkCwR"/>
                    <binomialProb spec="beast.core.parameter.RealParameter" value="0.5" estimate="false"/>
                </networkIntervals>
            </plugin>

            <operator id="reassortmentRateCwRScale" spec="ScaleOperator"
                parameter="@reassortmentRateCwR" scaleFactor="0.5" weight="1.0"/>

            <operator id="popSizeCwRScale" spec="ScaleOperator"
                parameter="@popSizeCwR" scaleFactor="0.5" weight="1.0"/>

            <operator id="addRemoveReassortmentCwR" spec="coalre.operators.AddRemoveReassortment"
                      network="@networkCwR" alpha="1.0" weight="1.0"/>

            <operator id="divertSegmentCwR" spec="coalre.operators.DivertSegmentOperator"
                      network="@networkCwR" weight="1.0"/>

            <operator id="uniformNetworkCwR" spec="coalre.operators.UniformNetworkNodeHeightOperator"
                      network="@networkCwR" weight="1.0"/>

            <operator id="networkScaleCwR" spec="coalre.operators.NetworkScaleOperator"
                      network="@networkCwR" weight="1.0"/>

            <operator id="networkScaleRootCwR" spec="coalre.operators.NetworkScaleOperator"
                      network="@networkCwR" scaleRootOnly="true" weight="1.0"/>
            ]]>

            <connect srcID="CoalescentWithReassortmentDummy.t:$(n)" targetID="prior" inputName="distribution"
                     if="inposterior(CoalescentWithReassortmentDummy.t:$(n)) and Tree.t:$(n)/estimate=true"/>
            <connect srcID="CoalescentWithReassortmentPrior" targetID="prior" inputName="distribution"
                     if="inposterior(CoalescentWithReassortmentDummy.t:$(n)) and Tree.t:$(n)/estimate=true"/>

            <connect srcID="reassortmentRateCwR" targetID="state" inputName="stateNode"
                     if="inposterior(CoalescentWithReassortmentPrior)"/>
            <connect srcID="popSizeCwR" targetID="state" inputName="stateNode"
                     if="inposterior(CoalescentWithReassortmentPrior)"/>
            <connect srcID="networkCwR" targetID="state" inputName="stateNode"
                     if="inposterior(CoalescentWithReassortmentPrior)"/>

            <connect srcID="reassortmentRateCwRScale" targetID="mcmc" inputName="operator"
                     if="inposterior(CoalescentWithReassortmentPrior)"/>
            <connect srcID="popSizeCwRScale" targetID="mcmc" inputName="operator"
                     if="inposterior(CoalescentWithReassortmentPrior)"/>
            <connect srcID="addRemoveReassortmentCwR" targetID="mcmc" inputName="operator"
                     if="inposterior(CoalescentWithReassortmentPrior)"/>
            <connect srcID="addRemoveReassortmentCwR" targetID="mcmc" inputName="operator"
                     if="inposterior(CoalescentWithReassortmentPrior)"/>
            <connect srcID="divertSegmentCwR" targetID="mcmc" inputName="operator"
                     if="inposterior(CoalescentWithReassortmentPrior)"/>
            <connect srcID="uniformNetworkCwR" targetID="mcmc" inputName="operator"
                     if="inposterior(CoalescentWithReassortmentPrior)"/>
            <connect srcID="networkScaleCwR" targetID="mcmc" inputName="operator"
                     if="inposterior(CoalescentWithReassortmentPrior)"/>
            <connect srcID="networkScaleRootCwR" targetID="mcmc" inputName="operator"
                     if="inposterior(CoalescentWithReassortmentPrior)"/>

            <connect srcID="Tree.t:$(n)" targetID="addRemoveReassortmentCwR" inputName="segmentTree"
                     if="inposterior(CoalescentWithReassortmentDummy.t:$(n)) and Tree.t:$(n)/estimate=true"/>
            <connect srcID="Tree.t:$(n)" targetID="divertSegmentCwR" inputName="segmentTree"
                     if="inposterior(CoalescentWithReassortmentDummy.t:$(n)) and Tree.t:$(n)/estimate=true"/>
            <connect srcID="Tree.t:$(n)" targetID="uniformNetworkCwR" inputName="segmentTree"
                     if="inposterior(CoalescentWithReassortmentDummy.t:$(n)) and Tree.t:$(n)/estimate=true"/>
            <connect srcID="Tree.t:$(n)" targetID="networkScaleCwR" inputName="segmentTree"
                     if="inposterior(CoalescentWithReassortmentDummy.t:$(n)) and Tree.t:$(n)/estimate=true"/>
            <connect srcID="Tree.t:$(n)" targetID="networkScaleRootCwR" inputName="segmentTree"
                     if="inposterior(CoalescentWithReassortmentDummy.t:$(n)) and Tree.t:$(n)/estimate=true"/>
            <connect srcID="Tree.t:$(n)" targetID="networkCwR" inputName="segmentTree"
                     if="inposterior(CoalescentWithReassortmentDummy.t:$(n)) and Tree.t:$(n)/estimate=true"/>

        </subtemplate>

    </mergewith>
</beast>


